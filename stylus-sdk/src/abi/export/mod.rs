// Copyright 2023-2024, Offchain Labs, Inc.
// For licensing, see https://github.com/OffchainLabs/stylus-sdk-rs/blob/main/licenses/COPYRIGHT.md

//! Traits for exporting Solidity interfaces.
//!
//! The contents of this module are imported when the `export-abi` feature flag is enabled,
//! which happens automatically during [`cargo stylus export-abi`][cargo].
//!
//! [cargo]: https://github.com/OffchainLabs/cargo-stylus#exporting-solidity-abis

use clap::Parser;
use core::fmt;
use lazy_static::lazy_static;
use regex::Regex;

#[doc(hidden)]
pub mod internal;

/// Export the Stylus contract ABI as a Solidity interface.
#[derive(Parser)]
struct ExportAbiArgs {
    /// Lisense of the generated ABI file.
    #[arg(long, default_value = "MIT-OR-APACHE-2.0")]
    license: String,

    /// Solidity pragma line on the generated ABI file.
    #[arg(long, default_value = "pragma solidity ^0.8.23;")]
    pragma: String,

    /// If true, export the constructor signature instead of the Solidity interface.
    #[arg(long)]
    constructor_signature: bool,
}

/// Prints the ABI given the CLI options.
pub fn print_from_args<T: GenerateAbi>() {
    let args = ExportAbiArgs::parse();
    if args.constructor_signature {
        print_constructor_signature::<T>();
    } else {
        print_abi::<T>(&args.license, &args.pragma);
    }
}

/// Trait for storage types so that users can print a Solidity interface to the console.
/// This is auto-derived via the [`public`] macro when the `export-abi` feature is enabled.
///
/// [`public`]: stylus-proc::public
pub trait GenerateAbi {
    /// The interface's name.
    const NAME: &'static str;

    /// How to format the ABI. Analogous to [`Display`](std::fmt::Display).
    fn fmt_abi(f: &mut fmt::Formatter<'_>) -> fmt::Result;

    /// How to format the constructor signature. Analogous to [`Display`](std::fmt::Display).
    fn fmt_constructor_signature(f: &mut fmt::Formatter<'_>) -> fmt::Result;
}

/// Type that makes an ABI printable.
struct AbiPrinter(fn(&mut fmt::Formatter<'_>) -> fmt::Result);

impl fmt::Display for AbiPrinter {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0(f)
    }
}

/// Prints the full contract ABI to standard out
pub fn print_abi<T: GenerateAbi>(license: &str, pragma: &str) {
    println!("/**");
    println!(" * This file was automatically generated by Stylus and represents a Rust program.");
    println!(" * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs).");
    println!(" */");
    println!();
    println!("// SPDX-License-Identifier: {license}");
    println!("{pragma}");
    println!();
    print!("{}", AbiPrinter(T::fmt_abi));
}

fn print_constructor_signature<T: GenerateAbi>() {
    print!("{}", AbiPrinter(T::fmt_constructor_signature));
}

lazy_static! {
    static ref UINT_REGEX: Regex = Regex::new(r"^uint(\d+)$").unwrap();
    static ref INT_REGEX: Regex = Regex::new(r"^int(\d+)$").unwrap();
    static ref BYTES_REGEX: Regex = Regex::new(r"^bytes(\d+)$").unwrap();
}

/// Prepends the string with an underscore if it is a Solidity keyword.
/// Otherwise, the string is unchanged.
/// Note: also prepends a space when the input is nonempty.
pub fn underscore_if_sol(name: &str) -> String {
    let underscore = || format!(" _{name}");

    if let Some(caps) = UINT_REGEX.captures(name) {
        let bits: usize = caps[1].parse().unwrap();
        if bits % 8 == 0 {
            return underscore();
        }
    }

    if let Some(caps) = INT_REGEX.captures(name) {
        let bits: usize = caps[1].parse().unwrap();
        if bits % 8 == 0 {
            return underscore();
        }
    }

    if let Some(caps) = BYTES_REGEX.captures(name) {
        let bits: usize = caps[1].parse().unwrap();
        if bits <= 32 {
            return underscore();
        }
    }

    match name {
        "" => "".to_string(),

        // other types
        "address" | "bool" | "int" | "uint" => underscore(),

        // other words
        "is" | "contract" | "interface" => underscore(),

        // reserved keywords
        "after" | "alias" | "apply" | "auto" | "byte" | "case" | "copyof" | "default"
        | "define" | "final" | "implements" | "in" | "inline" | "let" | "macro" | "match"
        | "mutable" | "null" | "of" | "partial" | "promise" | "reference" | "relocatable"
        | "sealed" | "sizeof" | "static" | "supports" | "switch" | "typedef" | "typeof" | "var" => {
            underscore()
        }
        _ => format!(" {name}"),
    }
}
