// Copyright 2023-2024, Offchain Labs, Inc.
// For licensing, see https://github.com/OffchainLabs/stylus-sdk-rs/blob/main/licenses/COPYRIGHT.md

//! Traits for exporting Solidity interfaces.
//!
//! The contents of this module are imported when the `export-abi` feature flag is enabled,
//! which happens automatically during [`cargo stylus export-abi`][cargo].
//!
//! [cargo]: https://github.com/OffchainLabs/cargo-stylus#exporting-solidity-abis

use clap::{Parser, Subcommand};
use core::fmt;
use lazy_static::lazy_static;
use regex::Regex;

#[doc(hidden)]
pub mod internal;

const DEFAULT_LICENSE: &str = "MIT-OR-APACHE-2.0";
const DEFAULT_PRAGMA: &str = "pragma solidity ^0.8.23;";

/// Export information about the Stylus contract.
#[derive(Parser)]
struct ExportCLI {
    #[command(subcommand)]
    commands: Option<ExportCommands>,
}

#[derive(Subcommand)]
enum ExportCommands {
    /// Export the Stylus contract ABI as a Solidity interface.
    Abi {
        /// Lisense of the generated ABI file.
        #[arg(long, default_value = DEFAULT_LICENSE)]
        license: String,
        /// Solidity pragma line on the generated ABI file.
        #[arg(long, default_value = DEFAULT_PRAGMA)]
        pragma: String,
    },
    /// Export the constructor signature.
    Constructor,
}

/// Prints the ABI given the CLI options.
pub fn print_from_args<T: GenerateAbi>() {
    let args = ExportCLI::parse();
    match args.commands {
        None => {
            print_abi::<T>(DEFAULT_LICENSE, DEFAULT_PRAGMA);
        }
        Some(ExportCommands::Abi { license, pragma }) => {
            print_abi::<T>(&license, &pragma);
        }
        Some(ExportCommands::Constructor) => {
            print_constructor_signature::<T>();
        }
    }
}

/// Trait for storage types so that users can print a Solidity interface to the console.
/// This is auto-derived via the [`public`] macro when the `export-abi` feature is enabled.
///
/// [`public`]: stylus-proc::public
pub trait GenerateAbi {
    /// The interface's name.
    const NAME: &'static str;

    /// How to format the ABI. Analogous to [`Display`](std::fmt::Display).
    fn fmt_abi(f: &mut fmt::Formatter<'_>) -> fmt::Result;

    /// How to format the constructor signature. Analogous to [`Display`](std::fmt::Display).
    fn fmt_constructor_signature(f: &mut fmt::Formatter<'_>) -> fmt::Result;
}

/// Type that makes an ABI printable.
struct AbiPrinter(fn(&mut fmt::Formatter<'_>) -> fmt::Result);

impl fmt::Display for AbiPrinter {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0(f)
    }
}

/// Prints the full contract ABI to standard out
pub fn print_abi<T: GenerateAbi>(license: &str, pragma: &str) {
    println!("/**");
    println!(" * This file was automatically generated by Stylus and represents a Rust program.");
    println!(" * For more information, please see [The Stylus SDK](https://github.com/OffchainLabs/stylus-sdk-rs).");
    println!(" */");
    println!();
    println!("// SPDX-License-Identifier: {license}");
    println!("{pragma}");
    println!();
    print!("{}", AbiPrinter(T::fmt_abi));
}

fn print_constructor_signature<T: GenerateAbi>() {
    print!("{}", AbiPrinter(T::fmt_constructor_signature));
}

lazy_static! {
    static ref UINT_REGEX: Regex = Regex::new(r"^uint(\d+)$").unwrap();
    static ref INT_REGEX: Regex = Regex::new(r"^int(\d+)$").unwrap();
    static ref BYTES_REGEX: Regex = Regex::new(r"^bytes(\d+)$").unwrap();
}

/// Prepends the string with an underscore if it is a Solidity keyword.
/// Otherwise, the string is unchanged.
/// Note: also prepends a space when the input is nonempty.
pub fn underscore_if_sol(name: &str) -> String {
    let underscore = || format!(" _{name}");

    if let Some(caps) = UINT_REGEX.captures(name) {
        let bits: usize = caps[1].parse().unwrap();
        if bits.is_multiple_of(8) {
            return underscore();
        }
    }

    if let Some(caps) = INT_REGEX.captures(name) {
        let bits: usize = caps[1].parse().unwrap();
        if bits.is_multiple_of(8) {
            return underscore();
        }
    }

    if let Some(caps) = BYTES_REGEX.captures(name) {
        let bits: usize = caps[1].parse().unwrap();
        if bits <= 32 {
            return underscore();
        }
    }

    match name {
        "" => "".to_string(),

        // other types
        "address" | "bytes" | "bool" | "int" | "uint" => underscore(),

        // other words
        "is" | "contract" | "interface" => underscore(),

        // reserved keywords
        "after" | "alias" | "apply" | "auto" | "byte" | "case" | "copyof" | "default"
        | "define" | "final" | "implements" | "in" | "inline" | "let" | "macro" | "match"
        | "mutable" | "null" | "of" | "partial" | "promise" | "reference" | "relocatable"
        | "sealed" | "sizeof" | "static" | "supports" | "switch" | "typedef" | "typeof" | "var" => {
            underscore()
        }
        _ => format!(" {name}"),
    }
}
