// Copyright 2023-2024, Offchain Labs, Inc.
// For licensing, see https://github.com/OffchainLabs/stylus-sdk-rs/blob/main/licenses/COPYRIGHT.md

use crate::imports::stylus_sdk::abi::AbiType;
use cfg_if::cfg_if;
use proc_macro2::TokenStream;
use quote::ToTokens;
use std::marker::PhantomData;
use syn::{parse::Nothing, parse_macro_input, parse_quote};

cfg_if! {
    if #[cfg(feature = "export-abi")] {
        mod export_abi;
        type Extension = export_abi::ExportAbiExtension;
    } else {
        type Extension = ();
    }
}

/// Implementation of the [`#[derive(AbiType)]`][crate::AbiType] macro.
pub fn derive_abi_type(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let item = parse_macro_input!(input as syn::ItemStruct);
    DeriveAbiTypeGenerator::<Extension>::from(item)
        .into_token_stream()
        .into()
}

struct DeriveAbiTypeGenerator<E: DeriveAbiTypeExtension = Extension> {
    item: syn::ItemStruct,
    _e: PhantomData<E>,
}

impl<E: DeriveAbiTypeExtension> DeriveAbiTypeGenerator<E> {
    /// Implement [`stylus_sdk::abi::AbiType`] for the given struct.
    ///
    /// The name is used for the ABI name to match the
    /// [`SolType::SOL_NAME`][alloy_sol_types::SolType::SOL_NAME] generated by the
    /// [`sol!`][alloy_sol_types::sol] macro.
    fn impl_abi_type(&self) -> syn::ItemImpl {
        let name = &self.item.ident;
        let name_str = name.to_string();
        let (impl_generics, ty_generics, where_clause) = self.item.generics.split_for_impl();

        parse_quote! {
            impl #impl_generics #AbiType for #name #ty_generics #where_clause {
                type SolType = Self;

                const ABI: stylus_sdk::abi::ConstString = stylus_sdk::abi::ConstString::new(#name_str);
            }
        }
    }
}

impl<E: DeriveAbiTypeExtension> From<syn::ItemStruct> for DeriveAbiTypeGenerator<E> {
    fn from(item: syn::ItemStruct) -> Self {
        Self {
            item: item,
            _e: PhantomData,
        }
    }
}

impl<E: DeriveAbiTypeExtension> ToTokens for DeriveAbiTypeGenerator<E> {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        self.impl_abi_type().to_tokens(tokens);
        E::codegen(&self.item).to_tokens(tokens);
    }
}

trait DeriveAbiTypeExtension {
    type Ast: ToTokens;
    fn codegen(item: &syn::ItemStruct) -> Self::Ast;
}

impl DeriveAbiTypeExtension for () {
    type Ast = Nothing;
    fn codegen(_item: &syn::ItemStruct) -> Nothing {
        Nothing
    }
}

#[cfg(test)]
mod tests {
    use super::DeriveAbiTypeGenerator;
    use crate::utils::testing::assert_ast_eq;
    use syn::parse_quote;

    #[test]
    fn test_impl_abi_type() {
        let item: syn::ItemStruct = parse_quote! {
            struct Foo<T>
            where T: Bar {
                a: bool,
                b: String,
                t: T,
            }
        };
        assert_ast_eq(
            DeriveAbiTypeGenerator::<()>::from(item).impl_abi_type(),
            parse_quote! {
                impl<T> stylus_sdk::abi::AbiType for Foo<T>
                where T: Bar {
                    type SolType = Self;

                    const ABI: stylus_sdk::abi::ConstString = stylus_sdk::abi::ConstString::new("Foo");
                }
            },
        )
    }
}
