// Copyright 2023-2024, Offchain Labs, Inc.
// For licensing, see https://github.com/OffchainLabs/stylus-sdk-rs/blob/main/licenses/COPYRIGHT.md

use crate::imports::stylus_sdk::abi::{AbiType, ConstString};
use cfg_if::cfg_if;
use proc_macro2::TokenStream;
use proc_macro_error::emit_error;
use quote::ToTokens;
use std::marker::PhantomData;
use stylus_core;
use syn::{parse::Nothing, parse_macro_input, parse_quote};

cfg_if! {
    if #[cfg(feature = "export-abi")] {
        mod export_abi;
        type Extension = export_abi::ExportAbiExtension;
    } else {
        type Extension = ();
    }
}

/// Implementation of the [`#[derive(AbiType)]`][crate::AbiType] macro.
pub fn derive_abi_type(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let item = parse_macro_input!(input as syn::ItemStruct);
    DeriveAbiTypeGenerator::<Extension>::from(item)
        .into_token_stream()
        .into()
}

struct DeriveAbiTypeGenerator<E: DeriveAbiTypeExtension = Extension> {
    item: syn::ItemStruct,
    _e: PhantomData<E>,
}

impl<E: DeriveAbiTypeExtension> DeriveAbiTypeGenerator<E> {
    /// Implement [`stylus_sdk::abi::AbiType`] for the given struct.
    ///
    /// The name is used for the ABI name to match the
    /// [`SolType::SOL_NAME`][alloy_sol_types::SolType::SOL_NAME] generated by the
    /// [`sol!`][alloy_sol_types::sol] macro.
    fn impl_abi_type(&self) -> syn::ItemImpl {
        let name = &self.item.ident;
        let name_str = name.to_string();
        if stylus_core::is_sol_keyword(&name_str) {
            emit_error!(
                name.span(),
                "struct name cannot be a Solidity keyword: `{}`",
                name_str
            );
        }

        let (impl_generics, ty_generics, where_clause) = self.item.generics.split_for_impl();
        let mut fields_selector_abis: Vec<syn::Expr> = Vec::new();
        for (i, item) in self.item.fields.iter().enumerate() {
            if i > 0 {
                fields_selector_abis.push(parse_quote! {
                    #ConstString::new(",")
                });
            }
            let item_ty = item.ty.clone();
            fields_selector_abis.push(parse_quote! {
                <#item_ty as #AbiType>::SELECTOR_ABI
            });
        }
        parse_quote! {
            #[cfg(not(feature = "contract-client-gen"))]
            impl #impl_generics #AbiType for #name #ty_generics #where_clause {
                type SolType = Self;

                const ABI: #ConstString = #ConstString::new(#name_str);

                const SELECTOR_ABI: #ConstString = #ConstString::new("(")
                    #(
                        .concat(#fields_selector_abis)
                    )*
                    .concat(#ConstString::new(")"));
            }
        }
    }
}

impl<E: DeriveAbiTypeExtension> From<syn::ItemStruct> for DeriveAbiTypeGenerator<E> {
    fn from(item: syn::ItemStruct) -> Self {
        Self {
            item,
            _e: PhantomData,
        }
    }
}

impl<E: DeriveAbiTypeExtension> ToTokens for DeriveAbiTypeGenerator<E> {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        self.impl_abi_type().to_tokens(tokens);
        E::codegen(&self.item).to_tokens(tokens);
    }
}

trait DeriveAbiTypeExtension {
    type Ast: ToTokens;
    fn codegen(item: &syn::ItemStruct) -> Self::Ast;
}

impl DeriveAbiTypeExtension for () {
    type Ast = Nothing;
    fn codegen(_item: &syn::ItemStruct) -> Nothing {
        Nothing
    }
}

#[cfg(test)]
mod tests {
    use super::DeriveAbiTypeGenerator;
    use crate::utils::testing::assert_ast_eq;
    use syn::parse_quote;

    #[test]
    fn test_impl_abi_type() {
        let item: syn::ItemStruct = parse_quote! {
            struct Foo<T>
            where T: Bar {
                a: bool,
                b: String,
                t: T,
            }
        };
        let result = DeriveAbiTypeGenerator::<()>::from(item).impl_abi_type();
        let expected = parse_quote! {
            #[cfg(not(feature = "contract-client-gen"))]
            impl<T> stylus_sdk::abi::AbiType for Foo<T>
            where T: Bar {
                type SolType = Self;

                const ABI: stylus_sdk::abi::ConstString = stylus_sdk::abi::ConstString::new("Foo");
                const SELECTOR_ABI: stylus_sdk::abi::ConstString = stylus_sdk::abi::ConstString::new("(")
                    .concat(<bool as stylus_sdk::abi::AbiType>::SELECTOR_ABI)
                    .concat(stylus_sdk::abi::ConstString::new(","))
                    .concat(<String as stylus_sdk::abi::AbiType>::SELECTOR_ABI)
                    .concat(stylus_sdk::abi::ConstString::new(","))
                    .concat(<T as stylus_sdk::abi::AbiType>::SELECTOR_ABI)
                    .concat(stylus_sdk::abi::ConstString::new(")"));
            }
        };
        assert_ast_eq(result, expected);
    }
}
